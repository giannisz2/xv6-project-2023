# xv6-project-2023

Ιωάννης Ζερμπίνος - 1115202000053 DOCUMENTATION 
Αρχικά πρόσθεσα στην proc.h την μεταβλητή "int priority" στο struct proc οπου χρειάζεται για να επιστρέφει την προτεραιότητα της συγκεκριμένης διεργασίας, καθώς και την αρχικοποίηση της στο allocproc() που βρίσκεται στο proc.c. Το struct pstat που περιέχει διάφορα στοιχεία των διεργασιών έχει οριστεί στο pstat.h και αποτελείται από πίνακες μεγέθους NPROC που θα περιέχουν ταυτόχρονα όλα τα δεδομένα όλων των διεργασιών. Έπειτα πρόσθεσα στην syscall.h δύο νέους αριθμούς που αντιστοιχούν στις δύο νέες κλήσεις συστήματος, στο user.h τους αριθμούς για τις κλήσεις, και στο usys.pl τις δύο κλήσεις σαν entries.

Μετά υλοποίησα τις δύο κλήσεις συστήματος στο sysproc.c ως εξής: 
•Στην uint64 sys_priority(void): Ορίζω μία μεταβλητή int num που θα χρησιμοποιηθεί στην argint() για να πάρω το όρισμα του priority. Έπειτα ελέγχω αν τα priorities βρίσκονται εντός ορίων και αν δεν βρίσκονται τότε επιστρέφει αποτυχημένα με -1. Αλλιώς παίρνω το struct της διεργασίας που τρέχει εκείνη τη στιγμή με την myproc() και αφού κάνω aqcuire() το lock ώστε να μην μπορεί άλλη διεργασία από άλλη cpu να γράψει εκεί κάτι ταυτόχρονα, θέτω το priority της διεργασίας σε num. Έπειτα κάνω release() το lock και επιστρέφω 0 (επιτυχία).
•Στην uint64 sys_getpinfo(void): Αρχικά ορίζω έναν uint64 pointer. Έπειτα παίρνω το struct της διεργασίας που τρέχει αυτή τη στιγμή με το myproc(), με την argaddr() παίρνω το όρισμα pstat που δίνεται από το ps.c στον pointer και κάνω kalloc() σε ενα *pstat struct. Χρησιμοποιώ την copyout() για error checking, και έπειτα διατρέχω όλες τις διεργασίες με ένα for loop. Μέσα στο for loop κάνω acquire() το lock για να μην μπορεί να γράψει κάποια άλλη διεργασία, ελέγχω αν η διεργασία είναι ενεργή ή έτοιμη να τρέξει, αντιγράφω όλα τα δεδομένα από το struct *p στο struct *pstat και εκτυπώνω τα αποτελέσματα. Έπειτα κάνω release() το lock και επιστρέφω 0 (επιτυχία).

Στη συνέχεια στο αρχείο ps.c απλά καλώ την getpinfo() όπου κάνει όλη την δουλειά και επίσης έχω προσθέσει στο Makefile στην γραμμή 136 το $U/_ps\ για να μπορώ να τρέξω το ps στον emulator. 

Η υλοποίηση του priority_scheduler() πραγματοποιήθηκε ως εξής: 
Ξεκινάω με τον ορισμό της μεταβλητής struct proc* p όπου θα χρησιμοποιήσω για το loop όπου διατρέχονται όλες οι διεργασίες.
Μετά παίρνω στην μεταβλητή struct cpu* c το struct της συγκεκριμένης cpu με την mycpu() και αρχικοποιώ την διεργασία της cpu σε 0.
Μέσα στο while(1): 
•Κάνω enable τα interrupts με το intr_on().
•Αρχικοποιώ το min σε 21 μιας και δεν μπορεί η διεργασία να έχει χαμηλότερη προτεραιότητα από 20.
•Αρχικοποιώ την νέα διεργασία που θα τρέξει σε 0.
•Ξεκινάω με το for loop να διατρέχω όλες τις διεργασίες που είναι έτοιμες να τρέξουν εκείνη την στιγμή και εκείνες που τρέχουν ήδη στην περίπτωση large εργασιών που έχουν υποστεί preempt, και ελέγχω αν η προτεραιότητα τους είναι μεγαλύτερη από τις άλλες. Όταν βρεθεί τη μεγαλύτερη, αυτή θα τρέξει.
•Αν τώρα έχει βρεθεί διεργασία με μεγαλύτερη προτεραιότητα, τότε ορίζω το state της σαν RUNNING, την τοποθετώ στην cpu, κάνω swtch() το context, και την αρχικοποιώ πάλι σε 0 γιατί σταμάτησε να τρέχει.
•Αν δεν έχει βρεθεί, πάει στην επόμενη.
Αν δύο διεργασίες έχουν ίδια προτεραιότητα στην ουσία θα επιλεγούν με πολιτική round-robin.

Τα usertests βγαίνουν ολα ΟΚ εκτός από τα killstatus (όπου κολλούσε εκεί χωρίς να εμφανίζει τίποτα), preempt (το ίδιο με το killstatus) και reparent (που επέστρεφε fail) όπου τα έκανα comment out στο usertests και απλά επιστρέφουν 0, ώστε να ελέγξχω και τα υπόλοιπα.
Στο priotest οι διεργασίες φαίνεται να εκτελούνται με τη σωστή σειρά.